Spring

·初识Spring
	·官网：spring.io
	·Spring发展到今天已经形成了一种开发生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能。
	·目前从 Spring Freamework 开始学习
	·然后从 Spring Boot 学习
	·然后学 Spring Cloud

·Spring Freamwork系统架构
	Spring Freamwork是Spring生态圈中最基础的项目，是其他项目的根基
	·Test：单元测试与集成测试
	·Core Container:核心容器
	·AOP：面向切面编程
	·Aspects：AOP思想实现
	
	·Web：Web开发
	
	·Data Integration：数据集成
	·Data Access：数据访问

学习路线：
	第一部分：核心容器
			核心概念（Ioc/DI）
			容器基本操作
	第二部分：整合
			整合数据层技术MyBatis
	第三部分：AOP
			核心概念
			AOP基础操作
			AOP实用开发
	第四部分：事务
			事务实用开发
	第五部分：家族
			SpringMVC
			SpringBoot
			SpringCloud

核心概念：
		·IoC/DI
			·代码书写现状：
				·耦合度偏高
			·解决方案：
				·使用对象时，在程序中不要主动使用new产生的对象，转换为由外部提供对象。
			·IoC（Inversion of Control）控制反转
				·对象的创建控制权由程序转移到外部，这种思想称为控制反转。
			·DI（Dependency Injection）依赖注入
				·在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入
			·目标：充分解耦
				·使用IoC容器管理bean(IoC)
				·在IoC容器内将有依赖关系的bean进行关系绑定(DI）
			·最终效果
				·使用对象时不仅可以直接从IoC容器中获取，并且获取到的bean已经绑定了所有的依赖关系
		·Ioc容器
			·Spring技术对IoC思想进行了实现
			·Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的“外部”。
		·Bean
			·Ioc容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean

IoC入门案例思路分析
1·管理什么？(Service与Dao)
2·如何将被管理的对象告知IoC容器？(配置)
3·被管理的对象交给IoC容器，如何获取到IoC容器？(接口)
4·IoC容器得到后，如何从容器中获取bean？(接口方法)
5·使用Spring导入哪些坐标？(pom.xml)

IoC入门案例(xml版本)
1·导入Spring坐标
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>

2·定义Spring管理的类(接口)

3·创建Spring配置文件，配置对应类作为Spring管理的bean
	<bean id="BookDao" class="demo01.dao.impl.BookDaoImpl"/>
    <bean id="BookService" class="demo01.service.impl.BookServiceImpl"/>

4·初始化IoC容器(Spring核心容器/Spring容器)，通过容器获取bean


DI入门案例思路分析
1·基于IoC管理bean
2·Service中使用new形式创建的Dao对象是否保留(否)
3·Service中需要的Dao对象如何进入到Service中？(提供方法)
4·Service与Dao间的关系如何描述？(配置)

DI入门案例
1·删除使用new形式创建的代码

2·提供依赖对象对应的setter方法

3·配置service与dao之间的关系
    <bean id="BookDao" class="demo01.dao.impl.BookDaoImpl"/>
    <bean id="BookService" class="demo01.service.impl.BookServiceImpl">
        <!--7·配置service与dao的关系-->
        <!--
            property标签表示配置当前bean的属性
            name属性表示拿一个具体的属性
            ref属性表示参照哪一个bean
        -->
        <property name="bookDao" ref="BookDao"/>

    </bean>

·bean可以定义多个别名，使用,;或者空格分隔
<beand id="bookDao" name="dao book bookDaoImpl" calss="dao.impl.BookDaoImpl">
·这里bookDao，dao，book，bookDaoImpl都是指同一个bean
·如果无法获取到bean,将会抛出 NoSuchBeanDefinitionException

·默认情况下，spring提供的bean是单例的
scope="singleton",如果要非单例的话,把singleton改为prototype
·为什么bean默认为单例？
1·减少新生成对象所造成的性能损耗
2·减少jvm垃圾回收
3·除了第一次获取bean之外，后续都是从缓存中获取，速度很快
·会有什么问题么？
·单例bean做不到线程安全，所有相关的请求都共享一个bean实例，所以这个bean如果有状态的话
在并发场景下可能会出现先问题。

·适合交给容器进行管理的bean
    ·表现层对象
    ·业务层对象
    ·数据层对象
    ·工具对象
·不适合交给容器尽心管理的bean
    ·封装实体的域对象

·bean实例化
    ·bean是如何创建的
        ·bean本质上就是对象，创建bean使用构造方法完成的
    ·实例化bean的三种方式
        1·运用无参构造(无论公有私有都可以)
        2·静态工厂(配置是配置工厂类名,然后加上factory-method="造对象的方法名")
            <bean id="orderDao" class="factory.OrderDaoFactory" factory-method="getOrderDao"/>
        3·实例工厂实例化Bean
            <bean id="userFactory" class="factory.UserDaoFactory">
            <bean id="userDao" factory-method="getUserDao" factory-bean="userFactory"/>
        4·使用FactoryBean实例化bean
            <bean id="userDao" class="factory.UserDaoFactoryBean"/>

·bean生命周期
    ·生命周期：从创建到消亡的完整过程
    ·bean生命周期：bean从创建到销毁的整体过程
        ·初始化容器
            1·创建对象(内存分配)
            2·执行构造方法
            3·执行属性注入(set操作)
            4·执行bean初始化方法
        ·使用bean
            1·执行业务操作
        3·关闭/销毁容器
            1·执行bean销毁方法
                ·手工关闭容器
                ·ClassPathXmlApplicationContext接口close()操作

                ·注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机
                ·ClassPathXmlApplicationContext接口registerShutdownHook()操作
    ·bean生命周期控制：在bean创建后到销毁前坐一些事情
        ·配置
            ·在对应类中写两个方法，在bean的配置中用init-method 和 destroy-method
                <bean id="bookdao" class="dao.impl.BookDaoImpl" init-method="init" destroy-method="destroy"/>
        ·接口
            ·在对应类实现 InitializingBean, DisposableBean接口,实现
            destroy()和afterPropertiesSet() 和 destroy()方法，
            这俩就是初始化和销毁前的方法操作

·依赖注入方式
    ·思考：
        ·向一个类中传递数据的方式有几种？
            ·普通方法(set方法)
            ·构造方法
        ·依赖注入描述了在容器中建立bean与bean之间依赖关系的过程，如果bean运行需要的是数字或者是字符串呢？
            ·引用类型
            ·简单类型(基本数据类型与String)
    ·依赖注入方式
        ·setter注入
            ·简单类型
                ·在bean中定义引用类型属性并提供可访问的set方法
                ·配置中使用property标签value属性注入简单类数据
            ·引用类型
                ·在bean中定义引用类型属性并提供可访问的set方法
                ·配置中使用property标签ref属性注入引用类数据
        ·构造器注入
            ·简单类型
                ·在bean中定义引用类型并提供可访问的构造方法
                ·配置中使用constructor-arg标签value属性注入引用类型对象
            ·引用类型
                ·在bean中定义引用类型并提供可访问的构造方法
                ·配置中使用constructor-arg标签ref属性注入引用类型对象

    ·依赖注入方式选择
        1·强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现
        2·可选依赖使用setter注入进行，灵活性强
        3·Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨
        4·如果有必要可以两者同时用，使用构造器注入完成强制依赖注入，使用setter注入完成可选依赖的注入
        5·实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入
        6·自己开发的模块推荐使用setter注入

·依赖自动装配
    ·IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配
    ·自动装配方式
        ·按类型(常用)
        ·按名称
        ·按构造方法
        ·不启用自动装配
    依赖自动装配特征
        ·自动装配用于引用类型依赖注入，不能对简单类型进行操作
        ·使用按类型装配时(byType)必须保障容器中相同类型的bean唯一，推荐使用
        ·使用按名称装配时(byName)必须保障容器中局邮指定名称的bean，因变量名与配置耦合，不推荐使用
        ·自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效

·集合注入
    ·略

·加载properties文件
    ·开启context命名空间
    ·使用context命名空间，加载指定properties文件
        ·用location="classpath*:*.properties"可以加载所有的properties文件
        ·system-properties-mode="NEVER" 就不会跟系统的变量名起冲突
    ·使用${}读取加载的属性值

·容器
    ·容器
    ·获取bean
        ·按名称
        ·按类型(容器中同一类型只能有一个)
        ·使用名称并指定类型
    ·容器类层次结构
    ·BeanFactory
        ·顶层

·核心容器总结
    ·容器相关
        ·BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载
        ·ApplicationContext接口时Spring容器的核心接口，初始化时bean立即加载
        ·ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展功能
        ·ApplicationContext接口常用初始化类
            ·ClaaPathXmlApplicationContext
            ·FileSystemXmlApplicationContext
    ·bean相关

    ·依赖注入相关

·注解开发
    ·注解开发定义bean
        1·写的类上添加注解
            ·@Component         通用
                ·@Controller    一般用于控制层
                ·@Service       一般用于业务层
                ·@Repository    一般用于数据层
           配置文件中这样弄
            <context:component-scan base-package="dao"/>
            <context:component-scan base-package="service"/>
    ·纯注解开发
        ·弄一个Config包，里面放一个SpringConfig类
            加上注解
                @Configuration
                @ComponentScan({"dao","service","control"})
                public class SpringConfig {
                }
        用到的类
        AnnotationConfigApplicationContext
        在一个类中引用其他的类作为自身属性的，不要用setter实例化
        直接用构造方法就行了


    ·bean作用范围
        ·类上添加注解
            @Scope("singleton")  单例
            或
            @Scope("prototype")  非单例
    ·bean生命周期
        ·方法上添加注解
        @PostConstruct      //初始化
        public void init(){
            System.out.println("book dao init...");
        }
        @PreDestroy         //销毁前
        public void destory(){
            System.out.println("book dao destory...");
        }

    ·依赖注入
        ·自动装配
